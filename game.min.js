/* Boid prototype */
"use strict";

function Boid(swarm) {
  GameObject(this); //extend from game object.
  this.x = Math.random() * swarm.width;
  this.y = Math.random() * swarm.height;
  this.radius = 6;
  this.speed = 2;
  this.radialSpeed = Math.PI / 60;
  this.vision = 50;
  this.heading = Math.random() * 2 * Math.PI - Math.PI;
}

// Boid.prototype.radius = 6;
// Boid.prototype.speed = 2;
// Boid.prototype.radialSpeed = Math.PI / 60;
// Boid.prototype.vision = 50;

Boid.prototype.render = function(ctx) {
    var pointLen = this.radius * 2.5;
    ctx.fillStyle = 'blue';
    ctx.beginPath();
    ctx.arc(this.x, this.y, this.radius, 0, 2 * Math.PI);
    ctx.fill();
    ctx.beginPath();
    ctx.moveTo(this.x + Math.cos(this.heading + Math.PI / 2) * this.radius,
               this.y + Math.sin(this.heading + Math.PI / 2) * this.radius);
    ctx.lineTo(this.x + Math.cos(this.heading + Math.PI) * pointLen,
               this.y + Math.sin(this.heading + Math.PI) * pointLen);
    ctx.lineTo(this.x + Math.cos(this.heading - Math.PI / 2) * this.radius,
               this.y + Math.sin(this.heading - Math.PI / 2) * this.radius);
    ctx.fill();
};

Boid.prototype.distance = function(boid, width, height) {
    var x0 = Math.min(this.x, boid.x), x1 = Math.max(this.x, boid.x);
    var y0 = Math.min(this.y, boid.y), y1 = Math.max(this.y, boid.y);
    var dx = Math.min(x1 - x0, x0 + width - x1);
    var dy = Math.min(y1 - y0, y0 + height - y1);
    return Math.sqrt(dx * dx + dy * dy);
};

Boid.prototype.getNeighbors = function(swarm) {
    var w = swarm.width, h = swarm.height;
    var neighbors = [];
    for (var i = 0; i < swarm.boids.length; i++) {
        var boid = swarm.boids[i];
        if (this !== boid && this.distance(boid, w, h) < this.vision) {
            neighbors.push(boid);
        }
    }
    return neighbors;
};

Boid.wrap = function(value) {
    var min, max;
    if (arguments.length === 2) {
        min = 0;
        max = arguments[1];
    } else if (arguments.length === 3) {
        min = arguments[1];
        max = arguments[2];
    } else {
        throw new Error('wrong number of arguments');
    }
    while (value >= max) value -= (max - min);
    while (value < min) value += (max - min);
    return value;
};

Boid.clamp = function(value, limit) {
    return Math.min(limit, Math.max(-limit, value));
};

Boid.meanAngle = function() {
    var sumx = 0, sumy = 0, len = arguments.length;
    for (var i = 0; i < len; i++) {
        sumx += Math.cos(arguments[i]);
        sumy += Math.sin(arguments[i]);
    }
    return Math.atan2(sumy / len, sumx / len);
};

Boid.prototype.step = function(swarm) {
    var w = swarm.width, h = swarm.height;
    var neighbors = this.getNeighbors(swarm);
    if (neighbors.length > 0) {
        var meanhx = 0, meanhy = 0;
        var meanx = 0, meany = 0;
        var mindist = this.radius * 2, min = null;
        for (var i = 0; i < neighbors.length; i++) {
            var boid = neighbors[i];
            meanhx += Math.cos(boid.heading);
            meanhy += Math.sin(boid.heading);
            meanx += boid.x;
            meany += boid.y;
            var dist = this.distance(boid, w, h);
            if (dist < mindist) {
                mindist = dist;
                min = boid;
            }
        }
        meanhx /= neighbors.length;
        meanhy /= neighbors.length;
        meanx /= neighbors.length;
        meany /= neighbors.length;

        var target;
        if (min) {
            // Keep away!
            target = Math.atan2(this.y - min.y, this.x - min.x);
        } else {
            // Match heading and move towards center
            var meanh = Math.atan2(meanhy, meanhx);
            var center = Math.atan2(meany - this.y, meanx - this.x);
            target = Boid.meanAngle(meanh, meanh, meanh, center);
        }

        // Move in this direction
        var delta = Boid.wrap(target - this.heading, -Math.PI, Math.PI);
        delta = Boid.clamp(delta, this.radialSpeed);
        this.heading = Boid.wrap(this.heading + delta, -Math.PI, Math.PI);
    }

    this.move(swarm);
};

Boid.prototype.move = function(swarm) {
    var padding = swarm.padding;
    var width = swarm.width, height = swarm.height;
    this.x = Boid.wrap(this.x + Math.cos(this.heading) * this.speed,
                       -padding, width + padding * 2);
    this.y = Boid.wrap(this.y + Math.sin(this.heading) * this.speed,
                       -padding, height + padding * 2);
};

Boid.prototype = Object.create(GameObject.prototype);
Boid.prototype.constructor = Boid;


/* Swam prototype. */

function Swarm(ctx) {
  GameObject(this); //extend from game object.
  this.ctx = ctx;
  this.boids = [];
  var swarm = this;
  this.animate = function() {
      Swarm.step(swarm);
  };
  this.padding = 8;
}

Swarm.prototype = Object.create(GameObject.prototype);
Swarm.prototype.constructor = Swarm;

Swarm.prototype.createBoid = function(n) {
    for (var i = 0; i < (n || 1); i++) {
        this.boids.push(new Boid(this));
    }
};

Swarm.prototype.clear = function() {
    this.boids = [];
};

Object.defineProperty(Swarm.prototype, 'width', {get: function() {
    return this.ctx.canvas.width;
}});

Object.defineProperty(Swarm.prototype, 'height', {get: function() {
    return this.ctx.canvas.height;
}});

Swarm.step = function (swarm) {
    var ctx = swarm.ctx;
    if (ctx.canvas.width != window.innerWidth)
        ctx.canvas.width = window.innerWidth;
    if (ctx.canvas.height != window.innerHeight)
        ctx.canvas.height = window.innerHeight;
    ctx.fillStyle = 'white';
    ctx.fillRect(0, 0, swarm.width, swarm.height);

    for (var i = 0; i < swarm.boids.length; i++) {
        swarm.boids[i].step(swarm);
        swarm.boids[i].draw(ctx);
    }
};

/* Test */
// var swarm; // defined globally for skewer
// $(document).ready(function() {
//     swarm = new Swarm($('#canvas').get(0).getContext('2d'));
//     swarm.id = setInterval(swarm.animate, 33);
//     swarm.animate();
//     swarm.clear();
//     swarm.createBoid(200);
// });

"use strict";

function entity(options) {
  var options = {

  }
}

"use strict";

function GameObject(obj) {
  // document.addEventListener("mousedown", function(e){
  //   obj.triggerListeners('mousedown', e);
  // }, false);
  // document.addEventListener("mouseup", function(e){
  //   obj.triggerListeners('mouseup', e);
  // }, false);
  // document.addEventListener("mousemove", function(e){
  //   obj.triggerListeners('mousemove', e);
  // }, false);

  document.addEventListener('DOMContentLoaded', function(){
    //var canvas = document.getElementsByTagName('canvas')[0];

    document.addEventListener("mousedown", function(e){
      obj.triggerListeners('mousedown', e);
    }, false);
    document.addEventListener("mouseup", function(e){
      obj.triggerListeners('mouseup', e);
    }, false);
    document.addEventListener("mousemove", function(e){
      obj.triggerListeners('mousemove', e);
    }, false);

    document.addEventListener("touchstart", function(e){
      obj.triggerListeners('touchstart', e);
    }, false);
    document.addEventListener("touchend", function(e){
      obj.triggerListeners('touchend', e);
    }, false);
    document.addEventListener("touchmove", function(e){
      obj.triggerListeners('touchmove', e);
    }, false);

  });

}

GameObject.prototype.render = function() {
  if (!this.listeners) {
    return;
  }

  this.listeners.forEach(function(listener){
    if (listener.type == 'render') {
      listener.callback();
    }
  });
};

GameObject.prototype.update = function(dt) {
  if (!this.listeners) {
    return;
  }

  this.listeners.forEach(function(listener){
    if (listener.type == 'update') {
      listener.callback(dt);
    }
  });
};

GameObject.prototype.addListener = function(type, callback) {
  if (!this.listeners) {
    this.listeners = [];
  }

  this.listeners.push({
    type: type,
    callback: callback
  });
};

GameObject.prototype.triggerListeners = function(type, event) {
  if (!this.listeners) {
    this.listeners = [];
  }

  this.listeners.forEach(function(listener){
    if (listener.type == type) {
      listener.callback(event);
    }
  });
};

"use strict";

// Global temp
//var fbo1, fbo2, blur1dShader, gaussianBlurShader, glowShader;

function Game(options) {
  GameObject(this); //extend from game object.
  this.canvas = null;
  this.scenes = [];
  this.keys = [];
  this.events = [];
  this.touch = false;
  this.width = options.width || 640;
  this.height = options.height || 480;
  this.messages = [];
  this.activeScene = -1;

  this.eventListeners = [];

  var lastDelta = Date.now();
  var dt = 0;
  var that = this;

  this.addScene = function(scene) {
    scene.parent = this;
    this.scenes.push(scene);
  }

  this.addEventListener = function(type, callback){
    this.eventListeners.push({
      type: type,
      callback: callback
    });
  }

  if (document.documentElement.requestFullscreen) {
    document.documentElement.requestFullscreen();
  }

  window.addEventListener("load", function() { window.scrollTo(0, 1); });

  this.init = function(canvas, webgl) {
    this.canvas = document.getElementById(canvas);
    this.canvas.width = this.width = window.innerWidth; //this.width;
    this.canvas.height = this.height = window.innerHeight; //this.height;
    this.ctx = this.canvas.getContext('2d');
    //old school looks.
    //this.ctx.imageSmoothingEnabled= false;

    // Setup WegGL
    this.webgl = document.getElementById(webgl);
    this.webgl.width = this.width = window.innerWidth; //this.width;
    this.webgl.height = this.height = window.innerHeight; //this.height;
    this.gl = this.webgl.getContext('webgl') || this.webgl.getContext("experimental-webgl");

    this.gl.viewport(0, 0, this.webgl.width, this.webgl.height);
    this.gl.pixelStorei(this.gl.UNPACK_FLIP_Y_WEBGL, true);

    var buffer = this.gl.createBuffer();
    this.gl.bindBuffer(this.gl.ARRAY_BUFFER, buffer);
    this.gl.bufferData(this.gl.ARRAY_BUFFER, new Float32Array([
      -1.0, -1.0,
      1.0, -1.0,
      -1.0,  1.0,
      -1.0,  1.0,
      1.0, -1.0,
      1.0,  1.0
    ]), this.gl.STATIC_DRAW);

    /*
    blur1dShader = glCreateShader(this.gl,
      `
        attribute vec2 p;
        varying vec2 uv;

        void main() {
          gl_Position = vec4(p,0.0,1.0);
          uv = 0.5 * (p+1.0);
        }
      `,
      `
        precision highp float;

        varying vec2 uv;
        uniform sampler2D t;
        uniform vec2 dim;
        uniform vec2 dir;

        void main() {
          vec4 color = vec4(0.0);
          vec2 off1 = vec2(1.3846153846) * dir;
          vec2 off2 = vec2(3.2307692308) * dir;
          color += texture2D(t, uv) * 0.2270270270;
          color += texture2D(t, uv + (off1 / dim)) * 0.3162162162;
          color += texture2D(t, uv - (off1 / dim)) * 0.3162162162;
          color += texture2D(t, uv + (off2 / dim)) * 0.0702702703;
          color += texture2D(t, uv - (off2 / dim)) * 0.0702702703;
          gl_FragColor = color;
        }
      `
    );
    this.gl.uniform2f(glUniformLocation(this.gl, blur1dShader, "dim"), this.webgl.width, this.webgl.height);

    fbo1 = glCreateFBO(this.gl, this.webgl.width, this.webgl.height);
    fbo2 = glCreateFBO(this.gl, this.webgl.width, this.webgl.height);

    this.textureGame = glCreateTexture(this.gl);
    */

    // Update scenes.
    this.addListener('update', function(dt){
      if (that.activeScene >= 0) {
        that.scenes[that.activeScene].update(dt);
      }
    });

    // Render scenes.
    this.addListener('render', function(dt){
      if (that.activeScene >= 0) {
        that.scenes[that.activeScene].render();
      }

      // Apply post effects.
      /*
      glSetTexture(that.gl, that.textureGame, that.canvas);

      glBindFBO(that.gl, fbo1);
      glBindShader(that.gl, blur1dShader);
      that.gl.uniform1i(glUniformLocation(that.gl, blur1dShader, "t"), glBindTexture(that.gl, that.textureGame, 0));
      that.gl.uniform2f(glUniformLocation(that.gl, blur1dShader, "dir"),  1.5, 1.5 );
      that.gl.drawArrays(that.gl.TRIANGLES, 0, 6);

      // that.gl.bindFramebuffer(that.gl.FRAMEBUFFER, null);
      // glBindShader(that.gl, gaussianBlurShader);
      // that.gl.uniform1i(glUniformLocation(that.gl, gaussianBlurShader, "image"), glBindTexture(that.gl, glGetFBOTexture(fbo1), 0));
      // that.gl.drawArrays(that.gl.TRIANGLES, 0, 6);


      that.gl.bindFramebuffer(that.gl.FRAMEBUFFER, null);
      glBindShader(that.gl, blur1dShader);
      that.gl.uniform1i(glUniformLocation(that.gl, blur1dShader, "t"), glBindTexture(that.gl, glGetFBOTexture(fbo1), 0));
      that.gl.uniform2f(glUniformLocation(that.gl, blur1dShader, "dir"),  -1.5, 1.5 );
      that.gl.drawArrays(that.gl.TRIANGLES, 0, 6);
      */
    });

    lastDelta = Date.now();
    loop();
  }

  function loop() {
    var now = Date.now();
    dt = (now - lastDelta) / 1000.0;
    // need to fix this:
    //that.ctx.clearRect(0, 0, that.width, that.height);
    //that.ctx.globalAlpha = 0.3;
    that.ctx.beginPath();
    that.ctx.rect(0, 0, that.width, that.height);
    that.ctx.fillStyle = 'black';
    that.ctx.fill();
    that.ctx.globalAlpha = 1;
    that.update(dt);
    that.render();

    lastDelta = now;
    window.requestAnimFrame(loop);
  }

  function triggerEventListeners(type, event) {
    that.eventListeners.forEach(function(listener){
      if (listener.type === type) {
        listener.callback(event);
      }
    });
  }

  window.addEventListener('resize', function(){
    that.canvas.width = window.innerWidth;
    that.canvas.height = window.innerHeight;
  }, false);

  document.addEventListener("keydown", function(e){
    that.keys[e.keyCode] = true;
    triggerEventListeners('keydown', e);
  }, false);
  document.addEventListener("keyup", function(e){
    that.keys[e.keyCode] = false;
    triggerEventListeners('keyup', e);
  }, false);

  document.addEventListener("touchstart", function(e){
    that.touch = true;
    triggerEventListeners('touchstart', e);
  }, false);
  document.addEventListener("touchend", function(e){
    that.touch = false;
    triggerEventListeners('touchend', e);
  }, false);

  document.addEventListener("mousedown", function(e){
    that.mouseEvent = e;
    that.touch = true;
    triggerEventListeners('mousedown', e);
  }, false);
  document.addEventListener("mouseup", function(e){
    that.mouseEvent = e;
    that.touch = false;
    triggerEventListeners('mouseup', e);
  }, false);
  document.addEventListener("mousemove", function(e){
    triggerEventListeners('mousemove', e);
  }, false);

}

Game.prototype = Object.create(GameObject.prototype);
Game.prototype.constructor = Game;

// Make an "universal" request animation frame.
window.requestAnimFrame = (function(){
  return window.requestAnimationFrame ||
  window.webkitRequestAnimationFrame ||
  window.mozRequestAnimationFrame    ||
  window.oRequestAnimationFrame      ||
  window.msRequestAnimationFrame     ||
  function( callback ){
    window.setTimeout(callback, 1000 / 60);
  };
})();

"use strict";

function Glitch() {
  GameObject(this); //extend from game object.
  this.position = {x: 0, y: 0};
  this.dimension = {
    w: 16,
    h: 16
  };
  this.distance = {
    x: Math.random() * (10) - 5,
    y: Math.random() * (10) - 5
  };
  this.velocity = Math.random() * (5) + 5;
  this.rotateTo = 0;
  this.angle = 0;
  this.timer = 0;

  var that = this;

  this.addListener('update', function(dt){
    // Check collision tests
    if (that.collisionTests) {
      that.collisionTests.forEach(function(collision){
        if (collision.type === 'player') {
          var rect1 = {
            x: collision.target.position.x,
            y: collision.target.position.y,
            width: collision.target.dimension.w,
            height: collision.target.dimension.h
          }
          var rect2 = {
            x: that.position.x,
            y: that.position.y,
            width: that.dimension.w,
            height: that.dimension.h
          }

          if (rect1.x < rect2.x + rect2.width &&
             rect1.x + rect1.width > rect2.x &&
             rect1.y < rect2.y + rect2.height &&
             rect1.height + rect1.y > rect2.y) {
               collision.collision = true;
               collision.callback(that, collision);
          }
        }

        if (collision.type === 'explosion') {
          var circle = {
            x: collision.target.position.x,
            y: collision.target.position.y,
            r: collision.target.bubble.w,
          };

          var rect = {
            x: that.position.x,
            y: that.position.y,
            w: that.dimension.w,
            h: that.dimension.h
          };

          var distX = Math.abs(circle.x - rect.x-rect.w/2);
          var distY = Math.abs(circle.y - rect.y-rect.h/2);

          if (distX > (rect.w/2 + circle.r)) { return false; }
          if (distY > (rect.h/2 + circle.r)) { return false; }

          if (distX <= (rect.w/2)) { collision.collision = true; }
          if (distY <= (rect.h/2)) { collision.collision = true; }

          var dx=distX-rect.w/2;
          var dy=distY-rect.h/2;

          collision.collision = (dx*dx+dy*dy<=(circle.r*circle.r));

          if ( collision.collision ) {
            collision.callback(that, collision);
          }
        }

        if (collision.type === 'emp') {
          var circle = {
            x: collision.target.position.x,
            y: collision.target.position.y,
            r: collision.target.bubble.w,
          };

          var rect = {
            x: that.position.x,
            y: that.position.y,
            w: that.dimension.w,
            h: that.dimension.h
          };

          var distX = Math.abs(circle.x - rect.x-rect.w/2);
          var distY = Math.abs(circle.y - rect.y-rect.h/2);

          if (distX > (rect.w/2 + circle.r)) { return false; }
          if (distY > (rect.h/2 + circle.r)) { return false; }

          if (distX <= (rect.w/2)) { collision.collision = true; }
          if (distY <= (rect.h/2)) { collision.collision = true; }

          var dx=distX-rect.w/2;
          var dy=distY-rect.h/2;

          collision.collision = (dx*dx+dy*dy<=(circle.r*circle.r));

          if ( collision.collision ) {
            collision.callback(that, collision);
          }
        }
      });
    }

    that.timer += dt * that.velocity;

    if (parseInt(that.timer) % 25 === 0 && parseInt(that.timer) % 50 != 0) {
      that.distance.x = Math.random() * (10) - 5;
    }

    if (parseInt(that.timer) % 50 === 0) {
      that.distance.y = Math.random() * (10) - 5;
    }

    var velX = that.distance.x * (dt * that.velocity);
    var velY = that.distance.y * (dt * that.velocity);

    that.position.x += velX;
    that.position.y += velY;

    if (that.position.x > that.parent.parent.width) {
      that.position.x = 0; //-= velX*2;
    }

    if (that.position.x < 0) {
      that.position.x = that.parent.parent.width; //-= velX*2;
    }

    if (that.position.y > that.parent.parent.height) {
      that.position.y = 0; // -= velY*2;
    }

    if (that.position.y < 0) {
      that.position.y = that.parent.parent.height; // -= velY*2;
    }

    that.angle = Math.atan2(that.distance.y,that.distance.x) * (180/Math.PI);

  });

  this.addListener('render', function(){
    var ctx = that.parent.parent.ctx;

    ctx.save();
    ctx.translate(that.position.x,that.position.y);
    //ctx.rotate(45 * Math.PI / 180);
    ctx.rotate(that.angle * Math.PI / 180);
    ctx.translate(-that.dimension.w/2,-that.dimension.h/2); // before we draw the sprite lets set the anchor point to its center.
    ctx.beginPath();
    //ctx.rect(that.position.x, that.position.y, that.dimension.w, that.dimension.h);
    ctx.rect(0, 0, that.dimension.w, that.dimension.h);
    //ctx.rect(that.position.x - (that.dimension.w / 2), that.position.y - (that.dimension.h / 2), that.dimension.w, that.dimension.h);
    ctx.fillStyle = 'red';
    ctx.fill();
    ctx.restore();
  });
}

Glitch.prototype = Object.create(GameObject.prototype);
Glitch.prototype.constructor = Glitch;

Glitch.prototype.addCollisionTest = function(target, type, callback){
  if (!this.collisionTests) {
    this.collisionTests = [];
  }

  this.collisionTests.push({
    target: target,
    type: type,
    callback: callback,
    collision: false
  });
};

Glitch.prototype.die = function(){
  this.triggerListeners('die', this);
}

"use strict";

/*
* Recursively merge properties of two objects
*/
Object.prototype.merge = function(object) {
  for (var p in object) {
    try {
      // Property in destination object set; update its value.
      if ( object[p].constructor==Object ) {
        this[p] = this.merge(object[p]); //this.merge(this[p], object[p]);
      } else {
        this[p] = object[p];
      }
    } catch(e) {
      // Property in destination object not set; create it and set its value.
      this[p] = object[p];
    }
  }

  return this;
};

"use strict";

function Player() {
  GameObject(this); //extend from game object.

  this.position = {x: 0, y: 0};
  this.dimension = {w: 32, h: 32};
  this.velocity = 5;
  this.moving = false;
  this.expanding = false;
  this.arming = false;
  this.exploding = false;
  this.colliding = false;
  this.spawning = false;
  this.spawningTimer = 0;
  this.dying = false;
  this.timer = 0;
  this.moveTo = {x: 0, y: 0};
  this.rotateTo = 0;
  this.angle = 0;
  this.lives = 3;

  this.bubble = {
    w: 0,
    h: 0,
    vel: 1,
    armed: {
      w: 0,
      h: 0
    }
  };

  var that = this;

  if (('ontouchstart' in window) ||
       (navigator.maxTouchPoints > 0) ||
       (navigator.msMaxTouchPoints > 0)) {

  } else {

  }

  this.addListener("touchmove", function(e){
    var touches = e.changedTouches;

    that.moveTo.x = touches[0].pageX;
    that.moveTo.y = touches[0].pageY;
    that.moving = true;

    if (!that.exploding && !that.arming) {
      that.exploding = false;
      that.arming = false;
      that.expanding = true;
    }
    e.preventDefault();
  });

  this.addListener("touchstart", function(e){
    var touches = e.changedTouches;

    if (that.arming) {
      that.moveTo.x = touches[0].pageX;
      that.moveTo.y = touches[0].pageY;
      that.moving = true;
    }

    that.expanding = true;
  });

  this.addListener("touchend", function(e){
    if (that.bubble.h > 32) {
      that.expanding = false;
      this.exploding = false;
      that.arming = true;
      that.timer = 0;
      that.bubble.armed.w = that.bubble.w;
      that.bubble.armed.h = that.bubble.h;
    } else {
      that.timer = 0;
      that.expanding = false;
      this.exploding = false;
      that.arming = false;
      that.bubble.armed.w = 0;
      that.bubble.w = 0;
      that.bubble.armed.h = 0;
      that.bubble.h = 0;

    }
  });

  this.addListener('update', function(dt){
    that.colliding = false;

    if (that.moving) {
      var xDistance = that.moveTo.x - that.position.x;
      var yDistance = that.moveTo.y - that.position.y;
      var distance = Math.sqrt(xDistance * xDistance + yDistance * yDistance);
      if (distance > 1) {
          that.position.x += xDistance * (dt * that.velocity);
          that.position.y += yDistance * (dt * that.velocity);
      } else {
        that.moving = false;
      }

      that.angle = Math.atan2(yDistance,xDistance) * (180/Math.PI);
    }

    if (that.expanding && that.bubble.h < 300) {
      that.bubble.w += 32 * (dt * that.bubble.vel);
      that.bubble.h += 32 * (dt * that.bubble.vel);
    }

    if (that.spawning) {
      that.spawningTimer += dt * that.velocity * 2;
      console.log(that.spawningTimer);
    }

    if (that.spawningTimer > 15) {
      that.spawningTimer = 0;
      that.spawning = false;
    }

    if (that.arming) {
      if (that.dimension.w <= 64) {
        that.dimension.w += 64 * (dt * that.bubble.vel);
        that.dimension.h += 64 * (dt * that.bubble.vel);

        that.bubble.w += 32 * (dt * that.bubble.vel);
        that.bubble.h += 32 * (dt * that.bubble.vel);
      }

      that.timer += dt * that.bubble.vel * 2;

      if (that.timer > 1) {
        that.timer = 0;
        that.arming = false;
        that.exploding = true;
        that.triggerListeners('start-explosion', that);
      }
    }

    if (that.exploding) {
      that.dimension.w = 32;
      that.dimension.h = 32;
      that.bubble.w = that.bubble.armed.w;
      that.bubble.h = that.bubble.armed.h;

      that.timer += dt * that.bubble.vel * 2;

      if (that.timer > 1) {
        that.timer = 0;
        that.exploding = false;
        that.bubble.w = 0;
        that.bubble.h = 0;
        that.triggerListeners('end-explosion', that);
      }
    }


  });

  this.addListener('render', function(){
    var ctx = that.parent.parent.ctx;

    ctx.save();

    if (that.spawning) {
      ctx.globalAlpha = parseInt(that.spawningTimer * 10) % 2 == 0?0.5:0;//0.5;
    }

    ctx.translate(that.position.x,that.position.y);
    //ctx.rotate(45 * Math.PI / 180);
    ctx.rotate(that.angle * Math.PI / 180);
    ctx.translate(-that.dimension.w/2,-that.dimension.h/2); // before we draw the sprite lets set the anchor point to its center.
    ctx.beginPath();
    //ctx.rect(that.position.x, that.position.y, that.dimension.w, that.dimension.h);
    ctx.rect(0, 0, that.dimension.w, that.dimension.h);
    //ctx.rect(that.position.x - (that.dimension.w / 2), that.position.y - (that.dimension.h / 2), that.dimension.w, that.dimension.h);
    ctx.fillStyle = that.colliding?'red':'white';
    ctx.fill();
    ctx.globalAlpha = 1;
    ctx.restore();

    if (that.expanding) {
      ctx.globalAlpha = 0.5;
      ctx.beginPath();
      ctx.arc(that.position.x, that.position.y, that.bubble.w, 0, 2 * Math.PI);
      ctx.fillStyle = '#00CCFF';
      ctx.fill();
      //ctx.stroke();
      ctx.globalAlpha = 1;

      // if (that.bubble.h < 100) {
      //   ctx.beginPath();
      //   ctx.strokeStyle = '#FFFFFF';
      //   ctx.lineWidth = 5;
      //   ctx.arc(that.position.x, that.position.y, that.bubble.w, that.bubble.w / 2, that.bubble.w / 2 + (Math.PI));
      //   ctx.stroke();
      // }
    }

    if (that.arming || that.expanding) {
      ctx.globalCompositeOperation = "overlay";
      for (var i = 0; i < 10; i++) {
        ctx.globalAlpha = 1;
        ctx.beginPath();
        ctx.strokeStyle = '#FFFFFF';
        ctx.lineWidth = 10;
        var bubbleRad = that.bubble.w - Math.random() * that.bubble.w;
        ctx.arc(that.position.x, that.position.y, bubbleRad, bubbleRad / 2, bubbleRad / 2 + (Math.PI));
        ctx.stroke();
        ctx.globalAlpha = 1;
      }
      ctx.globalCompositeOperation = "source-over";
    }

    if (that.arming) {
      ctx.globalAlpha = parseInt(that.timer * 10) % 2 == 0?0.5:0;//0.5;
      ctx.beginPath();
      ctx.arc(that.position.x, that.position.y, that.bubble.w, 0, 2 * Math.PI);
      ctx.fillStyle = '#00CCFF';
      ctx.fill();
      //ctx.stroke();
      ctx.globalAlpha = 1;
    }

    if (that.exploding) {
      ctx.globalAlpha = 1 - that.timer;
      ctx.beginPath();
      ctx.arc(that.position.x, that.position.y, that.bubble.w, 0, 2 * Math.PI);
      ctx.fillStyle = '#FFFFFF';
      ctx.fill();

      ctx.globalAlpha = 1 - that.timer * 5;
      ctx.beginPath();
      ctx.strokeStyle = '#FFFFFF';
      ctx.lineWidth = 10;
      ctx.arc(that.position.x, that.position.y, that.bubble.w + that.timer * 100, 0, 2 * Math.PI);
      ctx.stroke();

      //ctx.stroke();
      ctx.globalAlpha = 1;
    }
  });

}

Player.prototype = Object.create(GameObject.prototype);
Player.prototype.constructor = Player;

Player.prototype.die = function(){
  console.log('DIE!', this);
  this.lives--;
  this.spawning = true;
  this.triggerListeners('die', this);
};

Player.prototype.stopExpanding = function(){
  this.timer = 0;
  this.expanding = false;
  this.moving = false;
  this.exploding = false;
  this.arming = false;
  this.bubble.h = 0;
  this.bubble.w = 0;
};

"use strict";

function Scene() {
  GameObject(this); //extend from game object.
  this.entities = [];
  this.parent = null;
  var that = this;

  this.addEntity = function(entity) {
    entity.parent = that;
    this.entities.push(entity);
  };

  this.addListener('update', function(dt){
    that.entities.forEach(function(entity){
      entity.update(dt);
    });
  });

  this.addListener('render', function(dt){
    that.entities.forEach(function(entity){
      entity.render();
    });
  });
};

Scene.prototype = Object.create(GameObject.prototype);
Scene.prototype.constructor = Scene;

"use strict";

function Sprite(options) {
  options = {
    id: 0,
    test: 3
  }.merge(options);
}

"use strict";

function UI() {
  GameObject(this); //extend from game object.
  this.lives = 3;
  this.score = 0;
  //this.kills = 0;
  this.kills = {
    number: 0,
    x: 0,
    y: 0,
    show: false,
    timer: 0,
    dir: 1,
  };
  // this.showKills = false;
  // this.showKillsTimer = 0;
  var that = this;

  this.addListener('update', function(dt){
    if (that.kills.show) {
      that.kills.timer += dt * 1.5;
      that.kills.y--;

      if (that.kills.timer > 1) {
        that.kills.show = false;
        that.kills.timer = 0;
      }
    }

  });

  this.addListener('render', function(){
    var ctx = that.parent.parent.ctx;
    ctx.fillStyle = 'white';
    ctx.font = 'bold 24px "04b19"';
    ctx.fillText('Score:' + that.score, 10, 30);
    ctx.fillText('Lives:' + that.lives, 10, 60);

    if (that.kills.show) {
      ctx.save();
      //ctx.translate(that.kills.x,that.kills.y);
      ctx.globalAlpha = 1 - that.kills.timer;
      //ctx.scale(that.kills.timer + 1, that.kills.timer + 1);
      ctx.fillStyle = that.kills.number > 9 ? 'yellow' : 'white';
      ctx.font = 'bold ' + (that.kills.number > 9?'72px':'48px') + ' "04b19"';
      ctx.fillText(that.kills.number, that.kills.x, that.kills.y);
      ctx.globalAlpha = 1;
      ctx.restore();
    }
  });
};

UI.prototype = Object.create(GameObject.prototype);
UI.prototype.constructor = UI;

UI.prototype.displayKills = function(kills, x, y){
  this.kills.number = kills;
  this.kills.show = true;
  this.kills.x = x;
  this.kills.y = y;
  this.kills.dir = -1;

  if (y < 200) {
    this.kills.dir = 1;
  }

  this.kills.y = y + (50*this.kills.dir);
}

/* global gl, W, H, DEBUG */
var DEBUG = true;

function glCreateShader (gl, vert, frag) {
  var handle, type = gl.VERTEX_SHADER, src = vert;
  handle = gl.createShader(type);
  gl.shaderSource(handle, src);
  gl.compileShader(handle);
  var vertex = handle;

  if (DEBUG) {
    if (!gl.getShaderParameter(handle, gl.COMPILE_STATUS))
      throw gl.getShaderInfoLog(handle);
  }

  type = gl.FRAGMENT_SHADER;
  src = frag;
  handle = gl.createShader(type);
  gl.shaderSource(handle, src);
  gl.compileShader(handle);
  var fragment = handle;

  if (DEBUG) {
    if (!gl.getShaderParameter(handle, gl.COMPILE_STATUS))
      throw gl.getShaderInfoLog(handle);
  }

  var program = gl.createProgram();
  gl.attachShader(program, vertex);
  gl.attachShader(program, fragment);
  gl.linkProgram(program);

  if (DEBUG) {
    if (!gl.getProgramParameter(program, gl.LINK_STATUS))
      throw gl.getProgramInfoLog(program);
  }

  gl.useProgram(program);
  var p = gl.getAttribLocation(program, "p");
  gl.enableVertexAttribArray(p);
  gl.vertexAttribPointer(p, 2, gl.FLOAT, false, 0, 0);
  return [program];
}
function glBindShader (gl, shader) {
  gl.useProgram(shader[0]);
}
function glUniformLocation(gl, shader, name) {
  return shader[name] || (shader[name] = gl.getUniformLocation(shader[0], name));
}
function glCreateTexture (gl) {
  var tex = gl.createTexture();
  gl.bindTexture(gl.TEXTURE_2D, tex);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
  return tex;
}
function glSetTexture (gl, t, value) {
  gl.bindTexture(gl.TEXTURE_2D, t);
  gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, value);
}
function glBindTexture (gl, t, unit) {
  gl.activeTexture(gl.TEXTURE0 + unit);
  gl.bindTexture(gl.TEXTURE_2D, t);
  return unit;
}
function glCreateFBO (gl, w, h) {
  var handle = gl.createFramebuffer();
  gl.bindFramebuffer(gl.FRAMEBUFFER, handle);
  var color = glCreateTexture(gl);
  gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, w, h, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);
  gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, color, 0);
  return [handle, color];
}
function glBindFBO (gl, fbo) {
  gl.bindFramebuffer(gl.FRAMEBUFFER, fbo[0]);
}
function glGetFBOTexture (fbo) {
  return fbo[1];
}

"use strict";

var $; // Supa-dupa global game var.

(function(){
  $ = new Game({
    width: window.innerWidth,
    height: window.innerHeight/ 2,
  });

  $.init('canvas', 'webgl')

  var menu = new Scene();
  menu.timer = 0;
  menu.helpTexts = [
    {
      queue: [1,3],
      text: 'HOW TO PLAY...',
    },
    {
      queue: [4,6],
      text: 'TOUCH TO MOVE',
    },
    {
      queue: [6,8],
      text: 'AND TO ARM THE PULSE',
    },
    {
      queue: [14,18],
      text: 'RELEASE TO TRIGGER IT!',
    },
    {
      queue: [19,22],
      text: 'AFTER RELEASING THE PULSE',
    },
    {
      queue: [22,25],
      text: 'PLACE YOURSELF ABOVE',
    },
    {
      queue: [25,28],
      text: 'THE ENEMIES TO DESTROY THEM',
    },
    {
      queue: [30,35],
      text: 'GOOD LUCK!',
    },
  ];
  menu.addListener('render', function(){
    var ctx = $.ctx;
    var scale = (Math.abs(Math.cos(menu.timer)) / 2 + 2) / 3;

    // ctx.textAlign = 'left';
    // ctx.fillStyle = 'white';
    // ctx.font = 'bold 24px "04b19"';
    // ctx.fillText(menu.timer, 0, 20);

    ctx.save();
    ctx.translate($.width / 2, 100);
    ctx.scale(scale, scale);
    ctx.fillStyle = 'white';
    ctx.font = 'bold 120px "04b19"';
    ctx.textAlign = 'center';
    ctx.fillText('PULSE', 0, 40);
    ctx.restore();

    ctx.fillStyle = 'white';
    ctx.font = 'bold 24px "04b19"';
    ctx.textAlign = 'center';
    ctx.fillText('TOUCH TO START', $.width / 2, $.height - 80);

    menu.helpTexts.forEach(function(help){
      if (menu.timer > help.queue[0] && menu.timer < help.queue[1]) {
        ctx.fillStyle = 'white';
        ctx.font = 'bold 24px "04b19"';
        ctx.textAlign = 'center';
        ctx.fillText(help.text, $.width / 2, $.height / 2 - 80);
      }
    });
  });

  menu.addListener('update', function(dt){
    if (menu.parent && menu.parent.keys[32]) {
      $.activeScene = 1;
      menu.timer = 0;
    }

    if (menu.parent && menu.parent.touch && menu.timer > 2){
      $.activeScene = 1;
      menu.timer = 0;
    }

    menu.timer += dt * 2;

    if (parseInt(menu.timer) == 5) {
      menu.entities[0].expanding = true;
      menu.entities[0].moving = true;
      menu.entities[0].moveTo = {
        x: $.width / 2 + 30,
        y: $.height / 2
      };
    }

    if (parseInt(menu.timer) == 8) {
      menu.entities[0].moving = true;
      menu.entities[0].moveTo = {
        x: $.width / 2 - 30,
        y: $.height / 2 - 20
      };
    }

    if (parseInt(menu.timer) == 11) {
      menu.entities[0].moving = true;
      menu.entities[0].moveTo = {
        x: $.width / 2,
        y: $.height / 2
      };
    }


    if (parseInt(menu.timer) == 15) {
      menu.entities[0].expanding = false;
      menu.entities[0].arming = true;
    }

    if (parseInt(menu.timer) == 36) {
      menu.timer = 0;
    }

  });

  var demoPlayer = new Player();
  demoPlayer.position = {x: $.width / 2, y: $.height / 2};
  menu.addEntity(demoPlayer);

  $.addScene(menu);

  // Add game scene.
  var gameScene = new Scene();
  gameScene.timer = 0;
  gameScene.addListener('update', function(dt){
    if (player.lives == 0) {
      $.activeScene = 0;
      player.lives = 3;
      player.expanding = false;
      player.arming = false;
      player.exploding = false;
      player.spawning = false;
    }

    if (gameScene.parent && gameScene.parent.keys[32]) {
      console.log('Space pressed!');
    }

    if (gameScene.parent && gameScene.parent.touch){
      //console.log('Touched!');
    }

    gameScene.timer += dt * 20;

    // Every now and then, throw a new glitch.
    var interval = 50 - parseInt(gameScene.timer) / 10;
    if (interval < 0) {
      gameScene.timer = 0;
      interval = 50 - parseInt(gameScene.timer) / 10;
    }
    if (parseInt(gameScene.timer) % interval == 0) {
      var glitch = createGlitch();
      gameScene.addEntity(glitch);
      console.log('Another glitch');
    }

    // Every now and then, throw a free arming.
    if (parseInt(gameScene.timer) % 500 == 0) {
      console.log('Here comes salvation!');
      // var glitch = createGlitch();
      // gameScene.addEntity(glitch);
    }

    //console.log(gameScene.timer);
  });

  gameScene.addListener('spawn-glitches', function(){
    $.applyBlur();
  });

  var kills = 0;

  var player = new Player();
  player.position = {x: $.width / 2, y: $.height / 2};
  gameScene.addEntity(player);

  function createGlitch(){
    var glitch = new Glitch();
    //glitch.position = {x: Math.random() * 100, y: Math.random() * $.height};
    glitch.position = {
      x: Math.random() * 10 + (parseInt(Math.random() * 2) == 0?$.width - 10:0),
      y: Math.random() * 10 + (parseInt(Math.random() * 2) == 0?$.height - 10:0),
    };

    glitch.addCollisionTest(player, 'explosion', function(origin, collision){
      if (collision.target.exploding) {
        // origin.position = {
        //   x: Math.random() * 10 + (parseInt(Math.random() * 2) == 0?$.width - 10:0),
        //   y: Math.random() * 10 + (parseInt(Math.random() * 2) == 0?$.height - 10:0),
        // };
        origin.die();
        kills++;
        gameScene.entities.splice(gameScene.entities.indexOf(origin), 1);
      }
    });

    glitch.addCollisionTest(player, 'emp', function(origin, collision){
      if (!collision.target.exploding && !collision.target.arming && !collision.target.dying && !collision.target.spawning) {
        collision.target.die();
        collision.target.expanding = false;
        collision.target.stopExpanding();
      }
    });

    glitch.addCollisionTest(player, 'player', function(origin, collision){
      if (!collision.target.exploding && !collision.target.arming && !collision.target.dying && !collision.target.spawning) {
        collision.target.die();
        collision.target.colliding = true;
        //collision.target.life -= 0.1;
        //gameScene.entities.splice(gameScene.entities.indexOf(origin), 1);
      }
    });

    return glitch;
  }

  for (var i = 0; i < 50; i++) {
    var glitch = createGlitch();
    gameScene.addEntity(glitch);
  }

  $.addScene(gameScene);

  var ui = new UI();
  gameScene.addEntity(ui);
  player.addListener('die', function(player){
    ui.lives = player.lives;
  });

  player.addListener('start-explosion', function(player){
    kills = 0;
  });

  player.addListener('end-explosion', function(player){
    ui.score += kills + (kills * parseInt(kills / 2));
    ui.displayKills(kills, player.position.x, player.position.y);
  });

  $.activeScene = 0;
})();
//});
